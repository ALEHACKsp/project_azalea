// Interface to control the APIC (but not x2APIC)

//#define ENABLE_TRACING

#include "klib/klib.h"
#include "apic.h"
#include "pic.h"
#include "processor/x64/processor-x64-int.h"

const unsigned long APIC_ENABLED = 0x0000000000000800;
const unsigned char APIC_SPURIOUS_INT_VECTOR = 127;
const unsigned int APIC_SIV_FLAGS = 0x100;

// TODO: This will need extending to support multiple processors (MT)
static apic_registers *local_apic;

// Configures the system to use the APIC and IO APIC.
void proc_x64_configure_apic_mode()
{
  KL_TRC_ENTRY;

  COMPILER_ASSERT(sizeof(apic_registers) == 1024);

  asm_proc_disable_legacy_pic();
  proc_x64_configure_local_apic();

  end_of_irq_ack_fn = (void *)proc_x64_apic_irq_ack;

  KL_TRC_EXIT;
}

// Configures the processor's local APIC.
void proc_x64_configure_local_apic()
{
  KL_TRC_ENTRY;

  unsigned long apic_ctrl = asm_proc_read_msr(PROC_X64_MSRS::IA32_APIC_BASE);
  unsigned long apic_base_addr;
  unsigned long page_base;
  unsigned long offset;
  void *virtual_page;

  // Make sure the APIC is actually enabled. At this point, interrupts are still disabled (by use of CLI)
  KL_TRC_DATA("APIC control flags", apic_ctrl);
  if (!(apic_ctrl & APIC_ENABLED))
  {
    KL_TRC_TRACE((TRC_LVL_FLOW, "Enabling APIC\n"));
    apic_ctrl |= APIC_ENABLED;
    asm_proc_write_msr(PROC_X64_MSRS::IA32_APIC_BASE, apic_ctrl);
  }

  // The APICs registers need mapping so that we can actually access them!
  apic_base_addr = apic_ctrl & 0xFFFFFFFFFFFFF000;
  offset = apic_base_addr % MEM_PAGE_SIZE;
  page_base = apic_base_addr - offset;
  virtual_page = mem_allocate_virtual_range(1);
  mem_map_range((void *)page_base, virtual_page, 1, (task_process *)NULL, MEM_UNCACHEABLE);
  local_apic = (apic_registers *)(((unsigned long)virtual_page) + offset);

  // Configure a spurious interrupt vector, and using the magic flags, enable the APIC to send interrupts
  proc_configure_idt_entry(APIC_SPURIOUS_INT_VECTOR, 0, (void *)asm_proc_apic_spurious_interrupt);
  asm_proc_install_idt();
  local_apic->spurious_interrupt_vector = APIC_SIV_FLAGS | APIC_SPURIOUS_INT_VECTOR;

  KL_TRC_EXIT;
}

// Acknowledge an IRQ generated by the APIC.
void proc_x64_apic_irq_ack()
{
  local_apic->end_of_interrupt = 1;
}

unsigned char proc_x64_apic_get_local_id()
{
  KL_TRC_ENTRY;

  unsigned char id = ((local_apic->local_apid_id & 0xFF000000) >> 24);

  KL_TRC_DATA("Local APID ID", id);

  KL_TRC_EXIT;

  return id;
}
